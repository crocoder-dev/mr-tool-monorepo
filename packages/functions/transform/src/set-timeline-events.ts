import { eq, inArray } from "drizzle-orm";
import type { ExtractEntities, TransformEntities, TransformFunction } from "./config";
import type { NewMergeRequest as TransformedMergeRequest } from "@acme/transform-schema";
import type { MergeRequest as ExtractMergeRequest } from "@acme/extract-schema";
import { sql } from "drizzle-orm";

export type SetTimelineEventsInput = {
  mergeRequestId: ExtractMergeRequest["id"];
}
export type SetTimelineEventsOutput = void;
export type SetTimelineEventsExtractEntities = Pick<ExtractEntities, 'repositories' | 'mergeRequests' | 'timelineEvents'>;
export type SetTimelineEventsTransformEntities = Pick<TransformEntities, 'mergeRequests'>;

export type SetTimelineEventsFunction = TransformFunction<SetTimelineEventsInput, SetTimelineEventsOutput, SetTimelineEventsExtractEntities, SetTimelineEventsTransformEntities>;

export const setTimelineEvents: SetTimelineEventsFunction = async (
  { mergeRequestId },
  { extract, transform }
) => {
  let startedCodingAt: Date | null = null;
  let startedPickupAt: Date | null = null;
  let startedReviewAt: Date | null = null;

  let firstCommitAt: Date | null = null;
  let firstReviewEventAt: Date | null = null;
  let lastCommitAtBeforeReview: Date | null = null;

  let firstReviewCommentAt: Date | null = new Date(0); // TODO: read from mr-notes
  let lastCommitAtBeforeReviewCommentAt: Date | null = null;

  const timeline = await extract.db.select()
    .from(extract.entities.timelineEvents)
    .where(eq(extract.entities.timelineEvents.mergeRequestId, mergeRequestId))
    .all();


  // THE FOLLOWING TODO WAS GENERATED BY CODY:

  // TODO: Add a check for the merge request being closed, and if so, set the lastCommitAtBeforeReview to the last commit at before
  // TODO: the merge request was closed.
  // TODO: This will require adding a new column to the merge request table.
  // TODO: This will require adding a new column to the timeline event table.

  // Notes for above: Does that mean the timeline 

  let previousCommitAt: Date | null = null;
  for (const event of timeline) {
    if (
      lastCommitAtBeforeReview === null
      && previousCommitAt !== null
      && firstReviewEventAt !== null) lastCommitAtBeforeReview = previousCommitAt;
    if (firstReviewCommentAt !== null && event.type === 'committed' && event.timestamp > firstReviewCommentAt) lastCommitAtBeforeReviewCommentAt = previousCommitAt;

    if (startedPickupAt === null && ['review_requested', 'ready_for_review'].includes(event.type)) startedPickupAt = event.timestamp;

    // TODO: what if a review_comment (MergeRequestNote) timestamp is before the first review timestamp?
    if (firstReviewEventAt === null && ['commented', 'reviewed'].includes(event.type)) firstReviewEventAt = event.timestamp;

    if (event.type === 'committed') previousCommitAt = event.timestamp;
  }

  if (startedPickupAt === null) startedPickupAt = null; // TODO: smallest between lastCommitAtBeforeReviewCommentAt and lastCommitAtBeforeReview
}